package exposestrategy

import (
	"reflect"

	"github.com/pkg/errors"

	"k8s.io/kubernetes/pkg/api"
	"k8s.io/kubernetes/pkg/api/v1"
	"k8s.io/kubernetes/pkg/runtime"

	oclient "github.com/openshift/origin/pkg/client"
	rapi "github.com/openshift/origin/pkg/route/api"
	rapiv1 "github.com/openshift/origin/pkg/route/api/v1"
	apierrors "k8s.io/kubernetes/pkg/api/errors"
	client "k8s.io/kubernetes/pkg/client/unversioned"
)

type RouteStrategy struct {
	client  *client.Client
	oclient *oclient.Client
	encoder runtime.Encoder

	domain  string
	host    string
	usePath bool
}

var _ ExposeStrategy = &RouteStrategy{}

func NewRouteStrategy(client *client.Client, oclient *oclient.Client, encoder runtime.Encoder, domain, routeHost string, routeUsePath bool) (*RouteStrategy, error) {
	t, err := typeOfMaster(client)
	if err != nil {
		return nil, errors.Wrap(err, "could not create new route strategy")
	}
	if t == kubernetes {
		return nil, errors.New("route strategy is not supported on Kubernetes, please use Ingress strategy")
	}

	/*

		we don't need the domain for route mode!

		if len(domain) == 0 {
			domain, err = getAutoDefaultDomain(client)
			if err != nil {
				return nil, errors.Wrap(err, "failed to get a domain")
			}
			glog.Infof("Using domain: %s", domain)
		}
	*/

	rapi.AddToScheme(api.Scheme)
	rapiv1.AddToScheme(api.Scheme)

	return &RouteStrategy{
		client:  client,
		oclient: oclient,
		encoder: encoder,
		domain:  domain,
		host:    routeHost,
		usePath: routeUsePath}, nil
}

func (s *RouteStrategy) Add(svc *api.Service) error {
	// we don't need to fill in the host name as openshift will do that part for us!
	//hostName := fmt.Sprintf("%s.%s.%s", svc.Name, svc.Namespace, s.domain)

	createRoute := false
	route, err := s.oclient.Routes(svc.Namespace).Get(svc.Name)
	if err != nil {
		if apierrors.IsNotFound(err) {
			createRoute = true
			route = &rapi.Route{
				ObjectMeta: api.ObjectMeta{
					Namespace: svc.Namespace,
					Name:      svc.Name,
				},
			}
		} else {
			return errors.Wrapf(err, "could not check for existing route %s/%s", svc.Namespace, svc.Name)
		}
	}

	if route.Labels == nil {
		route.Labels = map[string]string{}
	}

	var hostName string
	protocol := "http"
	if createRoute {
		route.Labels["provider"] = "fabric8"
		path := ""
		if s.usePath {
			path = "/" + svc.Name
		}
		route.Spec = rapi.RouteSpec{
			To:   rapi.RouteTargetReference{Name: svc.Name},
			Host: s.host,
			Path: path,
		}

		route.Labels["generator"] = "exposecontroller"
		updated, err := s.oclient.Routes(route.Namespace).Create(route)
		if err != nil {
			return errors.Wrapf(err, "failed to create route %s/%s", route.Namespace, route.Name)
		}
		hostName, protocol = hostNameAndProtocolFromRoute(svc, updated)
	} else {
		// lets only update the route if the route that exists was not created by exposecontroller
		generator := route.Labels["generator"]
		if generator == "exposecontroller" {
			updated, err := s.oclient.Routes(route.Namespace).Update(route)
			if err != nil {
				return errors.Wrapf(err, "failed to update route %s/%s", route.Namespace, route.Name)
			}
			hostName, protocol = hostNameAndProtocolFromRoute(svc, updated)
		} else {
			//glog.Infof("Not updating route %s as it was not generated by exposecontroller", svc.Name)
			hostName, protocol = hostNameAndProtocolFromRoute(svc, route)
		}
	}

	cloned, err := api.Scheme.DeepCopy(svc)
	if err != nil {
		return errors.Wrap(err, "failed to clone service")
	}
	clone, ok := cloned.(*api.Service)
	if !ok {
		return errors.Errorf("cloned to wrong type: %s", reflect.TypeOf(cloned))
	}

	if len(hostName) == 0 {
		return errors.Wrap(err, "cannot add service annotation as OpenShift has not defaulted the hostName on the Route.Spec")
	}
	clone, err = addServiceAnnotationWithProtocol(clone, hostName, protocol)
	if err != nil {
		return errors.Wrap(err, "failed to add service annotation")
	}
	patch, err := createPatch(svc, clone, s.encoder, v1.Service{})
	if err != nil {
		return errors.Wrap(err, "failed to create patch")
	}
	if patch != nil {
		err = s.client.Patch(api.StrategicMergePatchType).
			Resource("services").
			Namespace(svc.Namespace).
			Name(svc.Name).
			Body(patch).Do().Error()
		if err != nil {
			return errors.Wrap(err, "failed to send patch")
		}
	}
	return nil
}

func hostNameAndProtocolFromRoute(svc *api.Service, route *rapi.Route) (string, string) {
	protocol := "http"
	spec := route.Spec
	hostName := spec.Host + spec.Path
	if spec.TLS != nil {
		protocol = "https"
	} else {
		protocol = findHttpProtocol(svc, hostName)
	}
	return hostName, protocol
}

func (s *RouteStrategy) Remove(svc *api.Service) error {
	err := s.oclient.Routes(svc.Namespace).Delete(svc.Name)
	if err != nil && !apierrors.IsNotFound(err) {
		return errors.Wrap(err, "failed to delete route")
	}

	cloned, err := api.Scheme.DeepCopy(svc)
	if err != nil {
		return errors.Wrap(err, "failed to clone service")
	}
	clone, ok := cloned.(*api.Service)
	if !ok {
		return errors.Errorf("cloned to wrong type: %s", reflect.TypeOf(cloned))
	}

	clone = removeServiceAnnotation(clone)

	patch, err := createPatch(svc, clone, s.encoder, v1.Service{})
	if err != nil {
		return errors.Wrap(err, "failed to create patch")
	}
	if patch != nil {
		err = s.client.Patch(api.StrategicMergePatchType).
			Resource("services").
			Namespace(clone.Namespace).
			Name(clone.Name).
			Body(patch).Do().Error()
		if err != nil {
			return errors.Wrap(err, "failed to send patch")
		}
	}

	return nil
}
